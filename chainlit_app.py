# =============================================================================
# FICHIER: chainlit_app.py - Version Compl√®te avec Support Visuel
# =============================================================================

import chainlit as cl
import sys
import os
import base64
import pandas as pd
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
import asyncio

# Ajouter le r√©pertoire src au path Python
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

# =============================================================================
# IMPORTS S√âCURIS√âS ET CONFIGURATION
# =============================================================================

def verify_environment():
    """V√©rifie que l'environnement est correctement configur√©"""
    
    required_vars = ["OPENAI_API_KEY", "PINECONE_API_KEY"]
    missing_vars = []
    
    for var in required_vars:
        if not os.getenv(var):
            missing_vars.append(var)
    
    if missing_vars:
        print(f"‚ùå Variables d'environnement manquantes: {missing_vars}")
        return False
    
    print("‚úÖ Variables d'environnement configur√©es")
    return True


def safe_import_simple_rag():
    """Import s√©curis√© du module simple_rag"""
    try:
        from simple_rag.graph import graph as simple_rag_graph
        from simple_rag.configuration import RagConfiguration
        print("‚úÖ simple_rag import√© avec succ√®s")
        return simple_rag_graph, RagConfiguration, True
    except ImportError as e:
        print(f"‚ùå Erreur import simple_rag: {e}")
        return None, None, False


# V√©rification et imports
if not verify_environment():
    print("‚ö†Ô∏è Veuillez configurer les variables d'environnement requises")
    sys.exit(1)

# Import du syst√®me RAG
simple_rag_graph, RagConfiguration, import_success = safe_import_simple_rag()

if not import_success:
    print("‚ùå Impossible d'importer simple_rag. V√©rifiez votre installation.")
    sys.exit(1)

# =============================================================================
# FONCTIONS D'AFFICHAGE VISUEL
# =============================================================================

async def detect_and_display_visual_content(documents: List[Any], user_question: str) -> Tuple[List[Any], bool]:
    """
    D√©tecte et affiche automatiquement le contenu visuel des documents r√©cup√©r√©s.
    
    Args:
        documents: Documents r√©cup√©r√©s par le RAG
        user_question: Question de l'utilisateur
        
    Returns:
        Tuple (documents_textuels, contient_elements_visuels)
    """
    text_documents = []
    visual_elements = []
    
    # Parcourir tous les documents pour identifier les √©l√©ments visuels
    for doc in documents:
        metadata = getattr(doc, 'metadata', {})
        doc_type = metadata.get('type', '')
        source_type = metadata.get('source_type', '')
        
        # Identifier les documents visuels
        if (doc_type in ['visual_chart', 'visual_table'] or 
            source_type == 'visual' or
            'image_path' in metadata or 
            'table_path' in metadata):
            
            visual_element = {
                'document': doc,
                'type': doc_type,
                'metadata': metadata,
                'content': getattr(doc, 'page_content', '')
            }
            visual_elements.append(visual_element)
        else:
            text_documents.append(doc)
    
    # Afficher les √©l√©ments visuels trouv√©s
    if visual_elements:
        print(f"üé® {len(visual_elements)} √©l√©ments visuels d√©tect√©s pour: {user_question}")
        await display_visual_elements(visual_elements, user_question)
        return text_documents, True
    
    return text_documents, False


async def display_visual_elements(visual_elements: List[Dict], user_question: str) -> None:
    """
    Affiche les √©l√©ments visuels dans l'interface Chainlit.
    
    Args:
        visual_elements: Liste des √©l√©ments visuels √† afficher
        user_question: Question de l'utilisateur (pour contexte)
    """
    # Message d'introduction pour les √©l√©ments visuels
    intro_msg = f"üìä **√âl√©ments visuels ANSD trouv√©s :**\n*{user_question}*\n"
    
    for i, element in enumerate(visual_elements, 1):
        element_type = element['type']
        metadata = element['metadata']
        
        # Extraire les informations importantes
        caption = metadata.get('caption', f'√âl√©ment visuel {i}')
        pdf_name = metadata.get('pdf_name', 'Document ANSD')
        page = metadata.get('page', metadata.get('page_num', 0))
        
        # Cr√©er le titre de l'√©l√©ment
        if element_type == 'visual_chart':
            title = f"üìä **Graphique {i}** : {caption}"
        elif element_type == 'visual_table':
            title = f"üìã **Tableau {i}** : {caption}"
        else:
            title = f"üìÑ **√âl√©ment {i}** : {caption}"
        
        # Informations sur la source
        source_info = f"*Source : {pdf_name}"
        if page:
            source_info += f", page {page}"
        source_info += "*"
        
        # Afficher selon le type
        try:
            if element_type == 'visual_chart':
                await display_chart_element(element, title, source_info, i)
            elif element_type == 'visual_table':
                await display_table_element(element, title, source_info, i)
            else:
                # √âl√©ment visuel g√©n√©rique
                await cl.Message(
                    content=f"{title}\n{source_info}\n\nüìù **Contenu :**\n{element['content'][:500]}..."
                ).send()
        except Exception as e:
            print(f"‚ùå Erreur affichage √©l√©ment {i}: {e}")
            # Affichage de fallback
            await cl.Message(
                content=f"{title}\n{source_info}\n\n‚ö†Ô∏è *Erreur d'affichage de l'√©l√©ment visuel*\n\nüìù **Contenu textuel :**\n{element['content'][:300]}..."
            ).send()


async def display_chart_element(element: Dict, title: str, source_info: str, index: int) -> None:
    """
    Affiche un graphique dans Chainlit.
    
    Args:
        element: √âl√©ment visuel de type graphique
        title: Titre format√© du graphique
        source_info: Informations sur la source
        index: Index de l'√©l√©ment
    """
    metadata = element['metadata']
    image_path = metadata.get('image_path', '')
    
    if not image_path:
        # Pas de chemin d'image, afficher seulement le contenu textuel
        await cl.Message(
            content=f"{title}\n{source_info}\n\nüìù **Contenu extrait :**\n{element['content']}"
        ).send()
        return
    
    # V√©rifier que le fichier image existe
    image_file = Path(image_path)
    if not image_file.exists():
        print(f"‚ö†Ô∏è Image non trouv√©e : {image_path}")
        await cl.Message(
            content=f"{title}\n{source_info}\n\n‚ö†Ô∏è *Image non disponible : {image_path}*\n\nüìù **Contenu extrait :**\n{element['content']}"
        ).send()
        return
    
    try:
        # Lire et encoder l'image
        with open(image_file, 'rb') as f:
            image_data = f.read()
        
        # Cr√©er l'√©l√©ment image pour Chainlit
        image_element = cl.Image(
            name=f"chart_{index}",
            content=image_data,
            display="inline",
            size="large"
        )
        
        # Pr√©parer le contenu du message
        content_parts = [title, source_info]
        
        if element['content']:
            # Limiter le contenu extrait pour l'affichage
            extracted_preview = element['content'][:400]
            if len(element['content']) > 400:
                extracted_preview += "..."
            content_parts.append(f"\nüìù **Contenu extrait :**\n{extracted_preview}")
        
        content = "\n".join(content_parts)
        
        # Afficher avec le message
        await cl.Message(
            content=content,
            elements=[image_element]
        ).send()
        
        print(f"‚úÖ Graphique affich√© : {image_file.name}")
        
    except Exception as e:
        print(f"‚ùå Erreur affichage graphique {image_path}: {e}")
        await cl.Message(
            content=f"{title}\n{source_info}\n\n‚ùå *Erreur lors du chargement de l'image*\n\nüìù **Contenu extrait :**\n{element['content']}"
        ).send()


async def display_table_element(element: Dict, title: str, source_info: str, index: int) -> None:
    """
    Affiche un tableau dans Chainlit.
    
    Args:
        element: √âl√©ment visuel de type tableau
        title: Titre format√© du tableau
        source_info: Informations sur la source
        index: Index de l'√©l√©ment
    """
    metadata = element['metadata']
    table_path = metadata.get('table_path', '')
    
    if not table_path:
        # Pas de chemin de tableau, afficher seulement le contenu textuel
        await cl.Message(
            content=f"{title}\n{source_info}\n\nüìù **Contenu extrait :**\n{element['content']}"
        ).send()
        return
    
    # V√©rifier que le fichier CSV existe
    table_file = Path(table_path)
    if not table_file.exists():
        print(f"‚ö†Ô∏è Tableau non trouv√© : {table_path}")
        await cl.Message(
            content=f"{title}\n{source_info}\n\n‚ö†Ô∏è *Tableau non disponible : {table_path}*\n\nüìù **Contenu extrait :**\n{element['content']}"
        ).send()
        return
    
    try:
        # Lire le CSV
        df = pd.read_csv(table_file)
        
        # Limiter l'affichage si le tableau est trop grand
        max_rows = 15
        max_cols = 8
        
        display_df = df.iloc[:max_rows, :max_cols]
        total_rows, total_cols = df.shape
        
        # Convertir en HTML pour l'affichage
        table_html = create_table_html(display_df, total_rows, total_cols, max_rows, max_cols)
        
        # Pr√©parer le contenu
        content_parts = [title, source_info, "\n", table_html]
        
        if element['content']:
            content_parts.append(f"\nüìù **Donn√©es extraites :**\n{element['content'][:200]}...")
        
        content = "\n".join(content_parts)
        
        # Afficher le tableau
        await cl.Message(content=content).send()
        
        print(f"‚úÖ Tableau affich√© : {table_file.name} ({total_rows}x{total_cols})")
        
    except Exception as e:
        print(f"‚ùå Erreur affichage tableau {table_path}: {e}")
        await cl.Message(
            content=f"{title}\n{source_info}\n\n‚ùå *Erreur lors du chargement du tableau*\n\nüìù **Contenu extrait :**\n{element['content']}"
        ).send()


def create_table_html(df: pd.DataFrame, total_rows: int, total_cols: int, max_rows: int, max_cols: int) -> str:
    """
    Cr√©e une repr√©sentation HTML d'un tableau pandas pour l'affichage dans Chainlit.
    """
    # Style CSS pour le tableau
    table_style = """
<style>
.ansd-table {
    border-collapse: collapse;
    width: 100%;
    margin: 10px 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 13px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border-radius: 8px;
    overflow: hidden;
}
.ansd-table th, .ansd-table td {
    border: 1px solid #e1e5e9;
    padding: 12px 8px;
    text-align: left;
    vertical-align: top;
}
.ansd-table th {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.5px;
}
.ansd-table tr:nth-child(even) {
    background-color: #f8f9fa;
}
.ansd-table tr:hover {
    background-color: #e3f2fd;
    transition: background-color 0.2s ease;
}
.table-info {
    font-style: italic;
    color: #6c757d;
    margin-top: 10px;
    padding: 8px 12px;
    background-color: #f8f9fa;
    border-left: 4px solid #007bff;
    border-radius: 0 4px 4px 0;
}
.ansd-table td {
    border-right: 1px solid #dee2e6;
}
.ansd-table td:last-child {
    border-right: none;
}
</style>
"""
    
    # Cr√©er le tableau HTML
    html_parts = [table_style, '<table class="ansd-table">']
    
    # En-t√™tes
    html_parts.append('<thead><tr>')
    for col in df.columns:
        html_parts.append(f'<th>{str(col)}</th>')
    if total_cols > max_cols:
        html_parts.append('<th>...</th>')
    html_parts.append('</tr></thead>')
    
    # Corps du tableau
    html_parts.append('<tbody>')
    for _, row in df.iterrows():
        html_parts.append('<tr>')
        for value in row:
            # Nettoyer et formater la valeur
            if pd.isna(value):
                clean_value = ''
            else:
                clean_value = str(value)
                # Formater les nombres si n√©cessaire
                try:
                    if '.' in clean_value and clean_value.replace('.', '').replace('-', '').isdigit():
                        num_value = float(clean_value)
                        if num_value.is_integer():
                            clean_value = str(int(num_value))
                        else:
                            clean_value = f"{num_value:.2f}"
                except:
                    pass
            
            html_parts.append(f'<td>{clean_value}</td>')
        
        if total_cols > max_cols:
            html_parts.append('<td>...</td>')
        html_parts.append('</tr>')
    html_parts.append('</tbody>')
    html_parts.append('</table>')
    
    # Informations sur la troncature
    info_parts = []
    if total_rows > max_rows:
        info_parts.append(f"Affichage des {max_rows} premi√®res lignes sur {total_rows}")
    if total_cols > max_cols:
        info_parts.append(f"Affichage des {max_cols} premi√®res colonnes sur {total_cols}")
    
    if info_parts:
        html_parts.append(f'<div class="table-info">üìä {" ‚Ä¢ ".join(info_parts)}</div>')
    else:
        html_parts.append(f'<div class="table-info">üìä Tableau complet : {total_rows} lignes √ó {total_cols} colonnes</div>')
    
    return ''.join(html_parts)


# =============================================================================
# FONCTIONS PRINCIPALES DU CHATBOT
# =============================================================================

async def call_simple_rag(user_input: str, chat_history: list) -> Tuple[str, List[Any]]:
    """
    Appelle directement le module simple_rag avec support visuel.
    
    Args:
        user_input: Question de l'utilisateur
        chat_history: Historique des conversations
        
    Returns:
        Tuple (r√©ponse, documents_r√©cup√©r√©s)
    """
    try:
        from langchain_core.messages import HumanMessage, AIMessage
        
        # Convertir l'historique en messages LangChain
        messages = []
        for user_msg, bot_msg in chat_history:
            messages.append(HumanMessage(content=user_msg))
            messages.append(AIMessage(content=bot_msg))
        
        # Ajouter le message actuel
        messages.append(HumanMessage(content=user_input))
        
        # Configuration pour simple_rag
        config = {
            "configurable": {
                "model": "openai/gpt-4o-mini",
                "api_key": os.getenv("OPENAI_API_KEY"),
                "pinecone_api_key": os.getenv("PINECONE_API_KEY"),
                "pinecone_index": "ansd-doc",
                "retriever_provider": "pinecone",
                
                # Param√®tres de r√©cup√©ration optimis√©s
                "retrieval_k": 20,
                "retrieval_fetch_k": 60,
                "enable_query_preprocessing": True,
                "enable_document_scoring": True,
                "prioritize_recent_data": True,
                
                # Support visuel
                "enable_visual_indexing": True,
                "images_dir": "images",
                "tables_dir": "tables"
            }
        }
        
        # Appeler simple_rag
        print(f"ü§ñ Appel simple_rag pour: {user_input}")
        result = await simple_rag_graph.ainvoke(
            {"messages": messages},
            config=config
        )
        
        # Extraire la r√©ponse et les documents
        if "messages" in result and result["messages"]:
            last_message = result["messages"][-1]
            answer = last_message.content
            
            # V√©rifier les m√©tadonn√©es visuelles
            response_metadata = getattr(last_message, 'response_metadata', {})
            has_visual = response_metadata.get('has_visual_content', False)
            
            print(f"‚úÖ R√©ponse g√©n√©r√©e. Contenu visuel: {'Oui' if has_visual else 'Non'}")
        else:
            answer = "‚ùå Aucune r√©ponse g√©n√©r√©e par le syst√®me."
        
        # R√©cup√©rer les documents pour l'affichage visuel
        documents = result.get("documents", [])
        
        return answer, documents
        
    except Exception as e:
        print(f"‚ùå Erreur dans call_simple_rag: {e}")
        import traceback
        traceback.print_exc()
        return f"‚ùå Erreur technique: {str(e)}", []


# =============================================================================
# INTERFACE CHAINLIT
# =============================================================================

@cl.on_chat_start
async def on_chat_start():
    """Initialisation du chat avec simple_rag"""
    
    await cl.Message(
        content="""üá∏üá≥ **Bienvenue dans TERANGA IA - ANSD**

**Assistant Intelligent pour les Statistiques du S√©n√©gal**

‚úÖ **Syst√®me simple_rag activ√©** avec support visuel automatique

üìä **Fonctionnalit√©s :**
‚Ä¢ R√©ponses expertes bas√©es sur les donn√©es officielles ANSD
‚Ä¢ Affichage automatique des graphiques et tableaux
‚Ä¢ Citations pr√©cises des sources et pages
‚Ä¢ Support des enqu√™tes : RGPH, EDS, ESPS, EHCVM, ENES

**üí° Exemples de questions :**
‚Ä¢ *"R√©partition des m√©nages par r√©gion selon la nature du rev√™tement du toit"*
‚Ä¢ *"√âvolution de la population du S√©n√©gal par ann√©e"*
‚Ä¢ *"Taux de pauvret√© par r√©gion administrative"*
‚Ä¢ *"Structure par √¢ge de la population s√©n√©galaise"*

**üéØ Posez votre question sur les statistiques du S√©n√©gal !**"""
    ).send()
    
    # Initialiser l'historique
    cl.user_session.set("chat_history", [])
    
    print("‚úÖ Session Chainlit initialis√©e avec simple_rag")


@cl.on_message
async def main(message):
    """Traitement principal des messages avec support visuel automatique"""
    
    try:
        # R√©cup√©rer l'historique
        chat_history = cl.user_session.get("chat_history", [])
        
        # Extraire le texte du message
        user_input = message.content
        
        print(f"üìù Question utilisateur: {user_input}")
        
        # Limiter l'historique envoy√© (garder les 10 derniers √©changes)
        short_history = chat_history[-10:]
        
        # Afficher un indicateur de traitement
        processing_msg = await cl.Message(
            content="üîç **Recherche dans la base de donn√©es ANSD...**\n\n*Analyse en cours avec simple_rag et d√©tection automatique du contenu visuel*"
        ).send()
        
        # Appeler simple_rag directement
        answer, documents = await call_simple_rag(user_input, short_history)
        
        # Supprimer le message de traitement
        await processing_msg.remove()
        
        # D√©tecter et afficher automatiquement le contenu visuel
        if documents:
            print(f"üìÑ {len(documents)} documents r√©cup√©r√©s")
            text_docs, has_visual = await detect_and_display_visual_content(documents, user_input)
            
            if has_visual:
                # Ajouter une note √† la r√©ponse
                answer += "\n\n*üìä Les √©l√©ments visuels correspondants sont affich√©s ci-dessus.*"
        
        # Afficher la r√©ponse textuelle
        await cl.Message(content=answer).send()
        
        # Mettre √† jour l'historique
        chat_history.append((user_input, answer))
        
        # Limiter la taille de l'historique
        if len(chat_history) > 20:
            chat_history = chat_history[-20:]
        
        cl.user_session.set("chat_history", chat_history)
        
        print(f"‚úÖ R√©ponse envoy√©e. Historique: {len(chat_history)} √©changes")
        
    except Exception as e:
        print(f"‚ùå Erreur dans main: {e}")
        import traceback
        traceback.print_exc()
        
        await cl.Message(
            content=f"‚ùå **Erreur technique**\n\nUne erreur s'est produite lors du traitement de votre question.\n\n*D√©tails: {str(e)}*\n\nVeuillez r√©essayer ou reformuler votre question."
        ).send()


# =============================================================================
# COMMANDES UTILITAIRES
# =============================================================================

@cl.on_message
async def handle_commands(message):
    """Gestion des commandes sp√©ciales"""
    
    content = message.content.lower().strip()
    
    # Commande d'aide
    if content in ["/help", "/aide", "aide", "help"]:
        help_text = """üÜò **Aide - Assistant ANSD**

**üìä Types de questions support√©es :**
‚Ä¢ Statistiques d√©mographiques (population, m√©nages, etc.)
‚Ä¢ Donn√©es √©conomiques (PIB, emploi, pauvret√©, etc.)
‚Ä¢ Indicateurs sociaux (√©ducation, sant√©, etc.)
‚Ä¢ R√©partitions g√©ographiques (par r√©gion, milieu, etc.)
‚Ä¢ √âvolutions temporelles et tendances

**üé® Affichage automatique :**
‚Ä¢ Graphiques : Affich√©s automatiquement quand pertinents
‚Ä¢ Tableaux : Format√©s en HTML avec donn√©es compl√®tes
‚Ä¢ Sources : Citations pr√©cises avec PDF et page

**üí° Conseils pour de meilleures r√©ponses :**
‚Ä¢ Soyez sp√©cifique : "population urbaine Dakar 2023"
‚Ä¢ Mentionnez le type de donn√©es : "taux de pauvret√©", "r√©partition"
‚Ä¢ Pr√©cisez la zone : "par r√©gion", "milieu rural/urbain"

**üîß Commandes disponibles :**
‚Ä¢ `/help` ou `/aide` : Afficher cette aide
‚Ä¢ `/debug` : Informations techniques
‚Ä¢ `/clear` : Effacer l'historique

**üìû Support :** En cas de probl√®me, reformulez votre question ou utilisez `/debug`"""
        
        await cl.Message(content=help_text).send()
        return
    
    # Commande de debug
    if content == "/debug":
        debug_info = f"""üîß **Informations de Debug**

**üèóÔ∏è Configuration :**
‚Ä¢ Syst√®me RAG : simple_rag activ√©
‚Ä¢ Support visuel : ‚úÖ Activ√©
‚Ä¢ Mod√®le : gpt-4o-mini
‚Ä¢ Index Pinecone : ansd-doc

**üìÅ Dossiers :**
‚Ä¢ Images : {Path('images').exists() and len(list(Path('images').glob('*.png')))} fichiers
‚Ä¢ Tableaux : {Path('tables').exists() and len(list(Path('tables').glob('*.csv')))} fichiers

**üîë API :**
‚Ä¢ OpenAI : {'‚úÖ Configur√©e' if os.getenv('OPENAI_API_KEY') else '‚ùå Manquante'}
‚Ä¢ Pinecone : {'‚úÖ Configur√©e' if os.getenv('PINECONE_API_KEY') else '‚ùå Manquante'}

**üíæ Session :**
‚Ä¢ Historique : {len(cl.user_session.get('chat_history', []))} √©changes"""
        
        await cl.Message(content=debug_info).send()
        return
    
    # Commande de nettoyage
    if content == "/clear":
        cl.user_session.set("chat_history", [])
        await cl.Message(content="üßπ **Historique effac√©**\n\nL'historique de conversation a √©t√© remis √† z√©ro.").send()
        return


# =============================================================================
# D√âMARRAGE DE L'APPLICATION
# =============================================================================

if __name__ == "__main__":
    print("üöÄ Lancement de TERANGA IA - ANSD")
    print("üìä Syst√®me simple_rag avec support visuel")
    print("üîó Interface Chainlit pr√™te")
    
    # L'application sera lanc√©e avec: chainlit run chainlit_app.py